# 数据检索

为了从PHP检索变量，你需要检查 存储在其中的任何符号表。以下代码为显示使用zend_hash_find()函数来实现此目的：

```c
{
  zval **fooval;
  if(zend_hash_find(EG(active_symbol_table), "foo", sizeof("foo"), (void**)&fooval) == SUCCESS){
    php_printf("Got the value of $foo!");
  }else{
    php_printf("$foo is not defined.");
  }
}
```

这个例子的几个部分 应该看起来有点滑稽。为什么fooval定义为两个层次的间接？为什么要使用sizeof()来确定"foo"的长度？为什么是 &fooval，它会评估一个zval \*\*\*，转换为一个void \*\*?如果你问自己这三个问题，那么请自求多福。

首先，值得一提的是，HashTables不仅用于PHP变量。HashTable结构非常通用，可以在整个引擎上使用，在某些情况下，想要存储非指针值是非常有意义的。然而，HashTable桶是固定大小的，所以为了存储任何大小的数据，HashTable将分配一块内存来包装正在存储的数据。在变量的情况下，它是一个zval \*被存储，所以HashTable存储机制分配一个足够大的内存块来保存一个指针。HashTable的bucket使用新的指针来运行zval \*，并且你可以在HashTable内部实现一个zval **。当HashTables显然能够存储完整的zval时，存储zval \*的原因将在下一章中介绍。

当尝试检索该数据时，HashTable只知道它有一个指向某物的指针。为了将该指针填充到调用函数的本地存储器中，调用函数将自然地取消引用本地指针，导致具有两个间接级别（例如void \*\*）的不确定类型的变量。知道在这种情况下你的”不确定类型“是zval \*，你可以看到传入zend_hash_find()的类型与编译器的位置不同，具有三级间接而不是两级。这是为了这样做，所以一个简单的类型转换被添加到函数调用 以沉默编译器警告。

在上个例子中使用了*sizeof()*的原因是 将终止NULL包含在用于变量标签的”foo“常量中。在这里使用4将同样有效；但是，由于对标签名称的更改可能会影响其长度，因此不建议更改标签名称，如果期中包含正在替换的标签文本，则可以轻松找到长度为硬编码的位置。*(strlen("foo")+1)*也可以解决这个问题；然而，一些编译器不会优化此步骤，并且生成的二进制文件可能会最终执行无意义的字符串长度循环，这必然不是一件有趣的事情。

如果*zend_hash_find()*找到你正在查找的项目，则将请求的数据首次添加到HashTable时，填充随分配的桶指针的地址提供的已解除引用的指针，并返回与SUCCESS常量匹配的整数值。如果*zend_hash_find()*找不到数据，它将保持指针不变，并返回与FAILURE常量匹配的整数值。

在PHP变量存储在符号表中的情况下，SUCCESS或FAILURE有效地意味着该变量是否设置。