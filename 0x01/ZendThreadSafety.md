# Zend线程安全

在PHP诞生之初，只是作为单进程CGI运行的，并不关心线程安全性，因为没有进程控件可以超过单个请求。内部变量可以在全据范围内被声明，只要其内容正确的初始化了，就可以随意访问或更改内部变量。任何没有被正确清理的资源都会在CGI进程终止时释放。

之后，PHP被嵌入到多进程Web服务器（如apache）中。一个给定的内部变量让然可以被全局定义并被请求安全访问，只要他每个请求开始时被正确的初始化，并在最后清理，因为每个进程控件的一个请求可以被激活一次。在这一点上，每个请求都被添加了内存管理，以防止资源泄漏造成程序失控。

随着单进程多线程Web服务器开始黯然失色，需要一中处理全局数据的新方法。最终，这将成为一个名为TSRM（线陈甘泉资源管理器）的新层。

## 线程安全与无线程安全的声明

在一个简单的单线程应用程序中，你很可能通过将它们放置在源文件的顶部来声明全局变量。而后，编译器将在程序的数据段中分配一个内存块以保存该单元的信息。

在多线程的应用程序中，每个线程都需要有自己的数据源素版本，因此必需为每个线程分配一个单独的内存块。然后，给定的线程在需要访问其数据的时候，选择正确的内存块和指针引用。

## 线程安全数据池

在一个扩展的MINIT阶段，扩展使用*ts_allocate_id()*函数通过TSRM层来存储一个或多个调用需要的数据。TSRM将该字节计数添加到其运行的数据空间需求总数，并为该段的线程数据池部分返回一个新的唯一标识符。

```c
typedef struct{
    int sampleint;
  	char *samplestring;
} php_sample_globals_id;
PHP_MINIT_FUNCTION(sample)
{
    ts_allocate_id(&sample_globals_id,
                  sizeof(php_sample_globals),
                  (ts_allocate_ctor) php_sample_globals_ctor,
                  (ts_allocate_dtor) php_sample_globals_dtor);
  	return SUCCESS;
}
```

当灾情求其减访问该数据段时，该扩展从TSRM层为当前线程的资源池请求一个指针，由*ts_allocate_id()*所返回的资源ID通过适当的索引将该指针进行了偏移。

## 什么时候不用线程

## 未知全局访问

##即使你不需要线程

## 找寻迷失的tsrm_ls

